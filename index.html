<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="UTF-8" />
  <title id="pageTitle">Atlas Cutter - v1.0.1</title>

  <!-- TailwindCSS -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Ramda -->
  <script src="https://cdn.jsdelivr.net/npm/ramda@0.29.0/dist/ramda.min.js"></script>

  <!-- JSZip -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <!-- PIXI.js v7 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js"></script>


  <style>
    canvas {
      image-rendering: pixelated;
    }

    .modal-bg {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 50;
    }

    .bg-checker {
      background-image:
        linear-gradient(45deg, #d1d5db 25%, transparent 25%),
        linear-gradient(-45deg, #d1d5db 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, #d1d5db 75%),
        linear-gradient(-45deg, transparent 75%, #d1d5db 75%);
      background-size: 10px 10px;
      background-position: 0 0, 0 5px, 5px -5px, -5px 0;
    }

    /* Flex container */
    #grid {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    /* Grid item style */
    .grid-item {
      width: 180px;
    }

    .grid-item-content {
      width: 100%;
      background: white;
      border-radius: 6px;
      box-shadow: 0 0 6px rgba(0, 0, 0, 0.15);
      padding: 6px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      transition: box-shadow 0.2s ease;
      position: relative;
    }

    .grid-item-content:hover {
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
    }

    .grid-item-checkbox {
      position: absolute;
      top: 8px;
      right: 8px;
      z-index: 10;
      cursor: pointer;
    }

    .sprite-preview-wrap {
      width: 100%;
      max-height: 200px;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .sprite-preview-wrap canvas {
      cursor: pointer;
      width: 100%;
      height: auto;
      max-height: 200px;
      image-rendering: pixelated;
      display: block;
      transform-origin: center center;
      transition: transform 0.12s ease-out;
    }

    .grid-item-content:hover .sprite-preview-wrap canvas {
      transform: scale(1.05);
    }

    /* Preview panel */
    #previewPanel {
      position: sticky;
      top: 96px;
      align-self: flex-start;
    }

    #previewCanvas {
      max-width: 100%;
      height: auto;
      image-rendering: pixelated;
      display: block;
    }
  </style>
</head>

<body class="bg-gray-100">

  <div class="max-w-6xl mx-auto py-8 px-4">
    <h1 id="pageHeading" class="text-3xl font-bold mb-4">üß© Atlas Cutter</h1>

    <!-- DropZone -->
    <div id="dropZone"
      class="border-2 border-dashed border-gray-400 bg-white rounded-lg p-6 text-center cursor-pointer transition">
      <div id="dropZoneContent">
        <p class="text-lg text-gray-700"></p>
      </div>
      <div id="filePreview" class="mt-4 hidden">
        <div id="fileList" class="text-sm text-left space-y-2"></div>
        <div id="imagePreview" class="mt-4 flex flex-wrap gap-4 justify-center"></div>
      </div>
      <input id="fileInput" type="file" multiple accept=".atlas,.png,.json" class="hidden" />
    </div>

    <div class="mt-4 flex gap-3">
      <button id="btnProcess" class="px-4 py-2 bg-blue-600 text-white rounded shadow"></button>
      <button id="btnClear" class="px-4 py-2 bg-red-600 text-white rounded shadow"></button>
    </div>

    <!-- Controls -->
    <div class="mt-6 flex flex-wrap gap-3 items-center text-sm">
      <input id="searchInput" placeholder="" class="border rounded px-3 py-1 w-56" />

      <select id="sortSelect" class="border rounded px-2 py-1">
        <option value="nameAsc"></option>
        <option value="nameDesc"></option>
        <option value="wAsc"></option>
        <option value="wDesc"></option>
        <option value="hAsc"></option>
        <option value="hDesc"></option>
      </select>

      <label class="flex items-center gap-2">
        <input type="checkbox" id="bboxToggle"> <span id="bboxLabel"></span>
      </label>

      <label class="flex items-center gap-2">
        <input type="checkbox" id="selectAllToggle" checked> <span id="selectAllLabel">Select All</span>
      </label>

      <select id="bgSelect" class="border rounded px-2 py-1">
        <option value="checker"></option>
        <option value="light"></option>
        <option value="dark"></option>
        <option value="transparent"></option>
      </select>

      <button id="btnMeta" class="px-3 py-1 bg-emerald-600 text-white rounded shadow"></button>

      <button id="btnZip" class="ml-auto px-3 py-1 bg-orange-600 text-white rounded shadow"></button>
    </div>

    <!-- GRID + PREVIEW LAYOUT -->
    <div class="mt-6 flex flex-col lg:flex-row gap-6">
      <!-- FLEX GRID -->
      <div id="grid" class="flex-1"></div>

      <!-- Dynamic Zoom Preview Panel -->
      <div id="previewPanel" class="w-full lg:w-80 bg-white rounded-lg shadow-md p-4 hidden relative">
        <button id="btnClosePreview" class="absolute top-2 right-2 text-gray-400 hover:text-gray-600 text-xl leading-none" title="Close">√ó</button>
        <h2 id="previewPanelTitle" class="text-sm font-semibold mb-2 flex items-center gap-1"></h2>
        <div id="previewTitle" class="text-xs font-semibold mb-1 truncate text-gray-800"></div>
        <div id="previewDim" class="text-[11px] text-gray-500 mb-2"></div>

        <div id="previewBgWrap" class="bg-checker rounded-md p-2 mb-3">
          <canvas id="previewCanvas"></canvas>
        </div>

        <div class="flex items-center gap-2 text-xs">
          <span id="zoomLabel" class="whitespace-nowrap"></span>
          <input id="zoomSlider" type="range" min="0.5" max="8" step="0.5" value="2" class="flex-1">
          <span id="zoomValue" class="w-10 text-right text-[11px] text-gray-500">2√ó</span>
        </div>

        <button id="btnFullscreen"
          class="mt-3 w-full px-3 py-1 text-xs bg-gray-800 text-white rounded hover:bg-gray-900"></button>

        <p id="previewTipText" class="mt-2 text-[11px] text-gray-500"></p>
      </div>
    </div>
  </div>

  <!-- Modal -->
  <div id="modal" class="hidden"></div>

  <!-- Templates -->
  <script type="text/template" id="template-fileList">
    <div class="grid grid-cols-3 gap-2 text-xs">
      <div class="bg-blue-50 p-2 rounded">
        <div class="font-semibold">{{fileTypeAtlas}}</div>
        <div class="text-gray-600">{{atlasCount}} {{fileCount}}</div>
      </div>
      <div class="bg-green-50 p-2 rounded">
        <div class="font-semibold">{{fileTypeImage}}</div>
        <div class="text-gray-600">{{pngCount}} {{fileCount}}</div>
      </div>
      <div class="bg-purple-50 p-2 rounded">
        <div class="font-semibold">{{fileTypeJson}}</div>
        <div class="text-gray-600">{{jsonCount}} {{fileCount}}</div>
      </div>
    </div>
    <div class="mt-2 text-xs text-gray-600 max-h-32 overflow-y-auto">
      {{fileItems}}
    </div>
  </script>

  <script type="text/template" id="template-gridItem">
    <div class="grid-item">
      <div class="grid-item-content">
        <input type="checkbox" class="grid-item-checkbox sprite-checkbox" checked>
        <div class="text-xs font-semibold text-center truncate w-full">{{spriteName}}</div>
        <div class="sprite-preview-wrap p-2 {{bgClass}}">
          <canvas width="{{spriteWidth}}" height="{{spriteHeight}}"></canvas>
        </div>
        <div class="text-[11px] text-gray-500 flex items-center gap-1 justify-center">
          {{spriteWidth}}√ó{{spriteHeight}} ‚Ä¢ 
          <a href="#" class="text-blue-600 hover:text-blue-800 underline download-link">{{download}}</a>
        </div>
      </div>
    </div>
  </script>

  <script>
    const $ = id => document.getElementById(id);

    // i18n translations
    const i18n = {
      title: "Atlas Cutter",
      dropZoneText: "üì¶ K√©o th·∫£ nhi·ªÅu file <b>.atlas + .png + .json</b> ho·∫∑c click ƒë·ªÉ ch·ªçn",
      dropZoneSelected: "‚úÖ ƒê√£ ch·ªçn {count} file",
      btnProcess: "C·∫Øt t·∫•t c·∫£ atlas",
      btnProcessCountdown: "C·∫Øt t·∫•t c·∫£ atlas ({seconds}s)",
      btnClear: "üóëÔ∏è Clear",
      btnMeta: "üìÑ Export Metadata JSON",
      btnZip: "üì¶ Download ZIP",
      searchPlaceholder: "üîç T√¨m sprite...",
      sortNameAsc: "T√™n A‚ÜíZ",
      sortNameDesc: "T√™n Z‚ÜíA",
      sortWAsc: "Width ‚Üë",
      sortWDesc: "Width ‚Üì",
      sortHAsc: "Height ‚Üë",
      sortHDesc: "Height ‚Üì",
      labelBbox: "Bounding box",
      selectAll: "Select All",
      bgChecker: "Checker",
      bgLight: "Light",
      bgDark: "Dark",
      bgTransparent: "Transparent",
      previewTitle: "üîç Dynamic Preview",
      previewZoom: "Zoom",
      btnFullscreen: "‚õ∂ Xem fullscreen",
      previewTip: "üí° Tip: Click v√†o sprite trong grid ƒë·ªÉ xem ·ªü ƒë√¢y. Double-click ƒë·ªÉ m·ªü fullscreen.",
      fileTypeAtlas: "Atlas (.atlas)",
      fileTypeImage: "Image (.png)",
      fileTypeJson: "JSON (.json)",
      fileCount: "file",
      download: "Download",
      alertNoFiles: "Ch∆∞a c√≥ file!",
      alertMissingFiles: "Kh√¥ng t√¨m th·∫•y ƒë·ªß 3 lo·∫°i file (atlas + png + json) cho c√πng m·ªôt t√™n base!"
    };

    // Helper function to get i18n text with optional replacements
    function t(key, replacements = {}) {
      let text = i18n[key] || key;
      Object.keys(replacements).forEach(k => {
        text = text.replace(`{${k}}`, replacements[k]);
      });
      return text;
    }

    // Helper function to render template
    function renderTemplate(templateId, data = {}) {
      const template = document.getElementById(templateId);
      if (!template) return null;
      
      let html = template.textContent || template.innerHTML;
      
      // Replace i18n keys with actual translations
      Object.keys(data).forEach(key => {
        if (key.startsWith('i18n_')) {
          const i18nKey = key.replace('i18n_', '');
          data[key] = t(i18nKey, data[key + '_replacements'] || {});
        }
      });
      
      // Replace placeholders
      Object.keys(data).forEach(key => {
        const value = data[key];
        if (value !== undefined && value !== null) {
          html = html.replace(new RegExp(`{{${key}}}`, 'g'), value);
        }
      });
      
      // Create container to parse HTML
      const container = document.createElement('div');
      container.innerHTML = html.trim();
      return container.firstChild || container;
    }

    // Helper function to render template as string (for innerHTML)
    function renderTemplateString(templateId, data = {}) {
      const template = document.getElementById(templateId);
      if (!template) return '';
      
      let html = template.textContent || template.innerHTML;
      
      // Replace i18n keys with actual translations
      Object.keys(data).forEach(key => {
        if (key.startsWith('i18n_')) {
          const i18nKey = key.replace('i18n_', '');
          data[key] = t(i18nKey, data[key + '_replacements'] || {});
        }
      });
      
      // Replace placeholders
      Object.keys(data).forEach(key => {
        const value = data[key];
        if (value !== undefined && value !== null) {
          html = html.replace(new RegExp(`{{${key}}}`, 'g'), value);
        }
      });
      
      return html;
    }

    // Element references
    const $dropZone = $("dropZone");
    const $dropZoneContent = $("dropZoneContent");
    const $filePreview = $("filePreview");
    const $fileList = $("fileList");
    const $imagePreview = $("imagePreview");
    const $fileInput = $("fileInput");
    const $grid = $("grid");
    const $bboxToggle = $("bboxToggle");
    const $previewPanel = $("previewPanel");
    const $previewTitle = $("previewTitle");
    const $previewDim = $("previewDim");
    const $previewCanvas = $("previewCanvas");
    const $previewBgWrap = $("previewBgWrap");
    const $zoomValue = $("zoomValue");
    const $modal = $("modal");
    const $btnProcess = $("btnProcess");
    const $btnClear = $("btnClear");
    const $sortSelect = $("sortSelect");
    const $searchInput = $("searchInput");
    const $bgSelect = $("bgSelect");
    const $btnMeta = $("btnMeta");
    const $btnZip = $("btnZip");
    const $zoomSlider = $("zoomSlider");
    const $btnFullscreen = $("btnFullscreen");
    const $btnClosePreview = $("btnClosePreview");
    const $selectAllToggle = $("selectAllToggle");

    // Initialize UI with i18n text
    function initI18n() {
      $("pageTitle").textContent = t("title");
      $("pageHeading").textContent = "üß© " + t("title");
      
      // Use template literal for drop zone
      $dropZoneContent.innerHTML = `<p class="text-lg text-gray-700">${t("dropZoneText")}</p>`;
      
      $btnProcess.textContent = t("btnProcess");
      $btnClear.textContent = t("btnClear");
      $searchInput.placeholder = t("searchPlaceholder");
      $sortSelect.options[0].textContent = t("sortNameAsc");
      $sortSelect.options[1].textContent = t("sortNameDesc");
      $sortSelect.options[2].textContent = t("sortWAsc");
      $sortSelect.options[3].textContent = t("sortWDesc");
      $sortSelect.options[4].textContent = t("sortHAsc");
      $sortSelect.options[5].textContent = t("sortHDesc");
      $("bboxLabel").textContent = t("labelBbox");
      $("selectAllLabel").textContent = t("selectAll");
      $bgSelect.options[0].textContent = t("bgChecker");
      $bgSelect.options[1].textContent = t("bgLight");
      $bgSelect.options[2].textContent = t("bgDark");
      $bgSelect.options[3].textContent = t("bgTransparent");
      $btnMeta.textContent = t("btnMeta");
      $btnZip.textContent = t("btnZip");
      $("previewPanelTitle").textContent = t("previewTitle");
      $("zoomLabel").textContent = t("previewZoom");
      $btnFullscreen.textContent = t("btnFullscreen");
      $("previewTipText").textContent = t("previewTip");
    }

    // Initialize i18n on page load
    initI18n();

    let files = [];
    let atlasList = {};
    let pngList = {};
    let jsonList = {};
    let allSprites = [];
    let bgMode = "checker";

    // Dynamic preview state
    let currentPreview = null;
    let previewZoom = 2;

    // Auto-process countdown
    let autoProcessTimeout = null;
    let countdownInterval = null;
    let countdownSeconds = 3;

    /* ------------------- Helper: BG Class ------------------- */
    function getBgClass(mode) {
      return ({
        checker: "bg-checker",
        light: "bg-gray-200",
        dark: "bg-slate-900",
        transparent: "bg-transparent"
      }[mode] || "bg-checker");
    }

    /* ------------------- CLEAR ALL ------------------- */
    function clearAll() {
      // Stop countdown
      stopAutoProcessCountdown();

      // Clear files
      files = [];
      atlasList = {};
      pngList = {};
      jsonList = {};
      allSprites = [];
      currentPreview = null;

      // Reset file input
      $fileInput.value = "";

      // Reset UI
      $filePreview.classList.add("hidden");
      $dropZoneContent.innerHTML = `<p class="text-lg text-gray-700">${t("dropZoneText")}</p>`;
      $grid.innerHTML = "";
      $previewPanel.classList.add("hidden");
      $searchInput.value = "";
      $sortSelect.value = "nameAsc";
      $bboxToggle.checked = false;
      $bgSelect.value = "checker";
      bgMode = "checker";
      previewZoom = 2;
      $zoomSlider.value = "2";
    }

    /* ------------------- AUTO-PROCESS COUNTDOWN ------------------- */
    function stopAutoProcessCountdown() {
      if (autoProcessTimeout) {
        clearTimeout(autoProcessTimeout);
        autoProcessTimeout = null;
      }
      if (countdownInterval) {
        clearInterval(countdownInterval);
        countdownInterval = null;
      }
      $btnProcess.textContent = t("btnProcess");
      $btnProcess.classList.remove("animate-pulse");
    }

    function updateCountdownButton() {
      if (countdownSeconds > 0) {
        $btnProcess.textContent = t("btnProcessCountdown", { seconds: countdownSeconds });
        $btnProcess.classList.add("animate-pulse");
      } else {
        $btnProcess.textContent = t("btnProcess");
        $btnProcess.classList.remove("animate-pulse");
      }
    }

    function startAutoProcessCountdown() {
      // Stop existing countdown if any
      stopAutoProcessCountdown();
      
      // Reset countdown
      countdownSeconds = 3;
      updateCountdownButton();
      
      // Update button every second
      countdownInterval = setInterval(() => {
        countdownSeconds--;
        updateCountdownButton();
        
        if (countdownSeconds <= 0) {
          stopAutoProcessCountdown();
          // Auto trigger process
          $btnProcess.click();
        }
      }, 1000);
    }

    /* ------------------- DRAG & DROP ------------------- */
    function updateFilePreview() {
      if (files.length === 0) {
        $filePreview.classList.add("hidden");
        $dropZoneContent.innerHTML = `<p class="text-lg text-gray-700">${t("dropZoneText")}</p>`;
        stopAutoProcessCountdown();
        return;
      }
      
      $filePreview.classList.remove("hidden");
      $dropZoneContent.innerHTML = `<p class="text-lg text-gray-700 font-semibold text-green-600">${t("dropZoneSelected", { count: files.length })}</p>`;
      
      // Group files
      const atlasFiles = files.filter(f => /\.atlas$/i.test(f.name));
      const pngFiles = files.filter(f => /\.png$/i.test(f.name));
      const jsonFiles = files.filter(f => /\.json$/i.test(f.name));
      
      // Render file items using template literal
      const fileItemsHtml = files.map(f => 
        `<div class="truncate">‚Ä¢ ${f.name}</div>`
      ).join('');
      
      $fileList.innerHTML = renderTemplateString("template-fileList", {
        fileTypeAtlas: t("fileTypeAtlas"),
        fileTypeImage: t("fileTypeImage"),
        fileTypeJson: t("fileTypeJson"),
        fileCount: t("fileCount"),
        atlasCount: atlasFiles.length,
        pngCount: pngFiles.length,
        jsonCount: jsonFiles.length,
        fileItems: fileItemsHtml
      });
      
      // Preview PNG images
      $imagePreview.innerHTML = "";
      pngFiles.forEach(file => {
        const reader = new FileReader();
        reader.onload = (e) => {
          const img = document.createElement("img");
          img.src = e.target.result;
          img.className = "max-w-32 max-h-32 object-contain border rounded shadow";
          img.title = file.name;
          $imagePreview.appendChild(img);
        };
        reader.readAsDataURL(file);
      });

      // Start auto-process countdown (reset if user adds more files)
      startAutoProcessCountdown();
    }
    
    $dropZone.onclick = () => $fileInput.click();
    ["dragenter", "dragover"].forEach(ev =>
      $dropZone.addEventListener(ev, e => {
        e.preventDefault();
        $dropZone.classList.add("border-blue-500", "bg-blue-50");
      })
    );
    ["dragleave", "drop"].forEach(ev =>
      $dropZone.addEventListener(ev, e => {
        e.preventDefault();
        $dropZone.classList.remove("border-blue-500", "bg-blue-50");
      })
    );
    $dropZone.addEventListener("drop", e => {
      files = [...e.dataTransfer.files];
      updateFilePreview();
    });
    $fileInput.onchange = e => {
      files = [...e.target.files];
      updateFilePreview();
    };

    /* ------------------- GROUP FILES ------------------- */
    const groupAtlasPngJson = (files) => {
      atlasList = {};
      pngList = {};
      jsonList = {};
      files.forEach(f => {
        const base = f.name.replace(/\.(atlas|png|json)$/i, "");
        if (/\.atlas$/i.test(f.name)) atlasList[base] = f;
        if (/\.png$/i.test(f.name)) pngList[base] = f;
        if (/\.json$/i.test(f.name)) jsonList[base] = f;
      });
      // Require all 3 file types for each base name
      return Object.keys(atlasList).filter(k => pngList[k] && jsonList[k]);
    };

    /* ------------------- PIXI PARSE ATLAS ------------------- */
    async function parseAtlasWithPIXI(atlasFile, pngFile, atlasName) {
      // Read .atlas file content (metadata)
      const atlasText = await atlasFile.text();

      // Parse metadata manually (xy, size, rotate)
      const regions = manualParseAtlas(atlasText, atlasName);

      // Create base texture from PNG blob
      const pngURL = URL.createObjectURL(pngFile);
      const baseTexture = new PIXI.BaseTexture(pngURL);

      // Iterate through each region and create sprite canvas
      return await Promise.all(
        regions.map(async region => {
          const { name, xy, size, rotate } = region;

          // Create sub-frame similar to actual texture atlas
          const frame = new PIXI.Rectangle(xy.x, xy.y, size.w, size.h);

          // Create sub-texture (not used directly, only for logic reference)
          const subTex = new PIXI.Texture(baseTexture, frame);

          // Export canvas
          const c = document.createElement("canvas");
          c.width = rotate ? size.h : size.w;
          c.height = rotate ? size.w : size.h;
          const ctx = c.getContext("2d");

          const img = new Image();
          img.src = pngURL;

          await new Promise(res => img.onload = res);

          if (rotate) {
            // Unrotate: sprite in PNG is rotated 90¬∞ clockwise, so we rotate -90¬∞ (counter-clockwise) to restore
            ctx.save();
            ctx.translate(c.width / 2, c.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.drawImage(
              img,
              xy.x, xy.y, size.w, size.h,
              -size.h / 2, -size.w / 2,
              size.h, size.w
            );
            ctx.restore();
          } else {
            ctx.drawImage(
              img,
              xy.x, xy.y, size.w, size.h,
              0, 0,
              size.w, size.h
            );
          }

          return {
            name,
            atlas: atlasName,
            canvas: c,
            w: c.width,
            h: c.height,
            xy,
            size,
            rotate
          };
        })
      );
    }

    /* ------------------- MANUAL METADATA PARSER ------------------- */
    function manualParseAtlas(text, atlasName) {
      const lines = text.split(/\r?\n/);
      let regions = [];
      let cur = null;
      let imageFileName = null;
      let imageFileNameWithoutExt = null;
      let foundImageFile = false;

      // Check if line is image file name (has image extension)
      const isImageFileName = (raw) => {
        const trimmed = raw.trim();
        if (!trimmed || raw.startsWith(" ") || trimmed.includes(":")) {
          return false;
        }
        const imageExtRegex = /\.(png|jpg|jpeg)$/i;
        return imageExtRegex.test(trimmed);
      };

      // Check if line is sprite name (not image file, not starting with space, no colon)
      const isSpriteName = (raw) => {
        const trimmed = raw.trim();
        if (!trimmed || raw.startsWith(" ") || trimmed.includes(":")) {
          return false;
        }
        // Exclude if it's an image file name
        return !isImageFileName(trimmed);
      };

      // Get base name without extension
      const getBaseName = (filename) => {
        return filename.replace(/\.(png|jpg|jpeg)$/i, "");
      };

      lines.forEach((raw) => {
        const line = raw.trim();

        // Find image file name (first non-empty line that matches criteria)
        if (!foundImageFile && isImageFileName(raw)) {
          imageFileName = line;
          imageFileNameWithoutExt = getBaseName(line);
          foundImageFile = true;
          return;
        }

        // Parse sprite names
        if (isSpriteName(raw)) {
          // Skip if sprite name matches image file name (with or without extension)
          if (imageFileName && (
            line === imageFileName || 
            line === imageFileNameWithoutExt
          )) {
            return;
          }

          cur && regions.push(cur);
          cur = {
            atlas: atlasName,
            name: line,
            rotate: false,
            xy: { x: 0, y: 0 },
            size: { w: 0, h: 0 }
          };
          return;
        }

        if (!cur) return;

        if (line.startsWith("rotate")) cur.rotate = line.includes("true");
        if (line.startsWith("xy:")) {
          const m = line.match(/xy:\s*(\d+),\s*(\d+)/);
          if (m) cur.xy = { x: +m[1], y: +m[2] };
        }
        if (line.startsWith("size:")) {
          const m = line.match(/size:\s*(\d+),\s*(\d+)/);
          if (m) cur.size = { w: +m[1], h: +m[2] };
        }
      });

      cur && regions.push(cur);
      return regions;
    }

    /* ------------------- RENDER FLEX GRID ------------------- */
    function renderGrid(sprites) {
      $grid.innerHTML = "";

      const bgClass = getBgClass(bgMode);

      sprites.forEach(s => {
        // Render template
        const item = renderTemplate("template-gridItem", {
          spriteName: s.name,
          spriteWidth: s.w,
          spriteHeight: s.h,
          bgClass: bgClass,
          download: t("download")
        });

        // Get elements from template
        const preview = item.querySelector("canvas");
        const downloadLink = item.querySelector(".download-link");
        const checkbox = item.querySelector(".sprite-checkbox");

        // Store sprite name in checkbox data attribute for easy lookup
        checkbox.dataset.spriteName = s.name;

        // Setup checkbox event listener
        checkbox.onchange = () => {
          updateSelectAllCheckbox();
        };

        // Prevent checkbox click from triggering grid item click
        checkbox.onclick = (e) => {
          e.stopPropagation();
        };

        // Setup canvas
        const ctx = preview.getContext("2d");
        ctx.drawImage(s.canvas, 0, 0);

        if ($bboxToggle.checked) {
          ctx.strokeStyle = "red";
          ctx.lineWidth = 1.2;
          ctx.strokeRect(0, 0, s.w, s.h);
        }

        // Wheel zoom (local sprite zoom)
        let zoom = 1;
        preview.onwheel = e => {
          e.preventDefault();
          zoom += (e.deltaY < 0 ? 0.2 : -0.2);
          zoom = Math.min(8, Math.max(0.5, zoom));
          preview.style.transform = `scale(${zoom})`;
        };

        // Click = update dynamic preview panel
        preview.onclick = () => setPreviewSprite(s);

        // Double-click = fullscreen modal
        preview.ondblclick = () => showModal(s.canvas);

        // Setup download link
        downloadLink.onclick = (e) => {
          e.preventDefault();
          s.canvas.toBlob(blob => {
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `${s.name}.png`;
            a.click();
            URL.revokeObjectURL(url);
          });
        };

        $grid.appendChild(item);
      });

      // Update select all checkbox state
      updateSelectAllCheckbox();

      // Repaint preview if sprite is currently selected
      updatePreviewCanvas();
    }

    /* ------------------- Sorting ------------------- */
    function sortSprites(arr, type) {
      switch (type) {
        case "nameAsc": return R.sortBy(s => s.name.toLowerCase(), arr);
        case "nameDesc": return R.sort(R.descend(s => s.name.toLowerCase()), arr);
        case "wAsc": return R.sortBy(s => s.w, arr);
        case "wDesc": return R.sort(R.descend(s => s.w), arr);
        case "hAsc": return R.sortBy(s => s.h, arr);
        case "hDesc": return R.sort(R.descend(s => s.h), arr);
      }
      return arr;
    }

    /* ------------------- Modal ------------------- */
    function showModal(canvas) {
      $modal.innerHTML = `
        <div class="modal-bg" onclick="closeModal()">
          <img src="${canvas.toDataURL()}" class="max-w-[90vw] max-h-[90vh] bg-white shadow-lg border" />
        </div>`;
      $modal.classList.remove("hidden");
    }
    function closeModal() {
      $modal.classList.add("hidden");
    }

    /* ------------------- Dynamic Preview Panel ------------------- */
    function closePreviewPanel() {
      $previewPanel.classList.add("hidden");
      currentPreview = null;
    }

    function setPreviewSprite(s) {
      currentPreview = s;
      if ($previewPanel.classList.contains("hidden")) {
        $previewPanel.classList.remove("hidden");
      }
      $previewTitle.textContent = s.name;
      $previewDim.innerHTML = `${s.w}√ó${s.h} ‚Ä¢ `;
      
      // Use template literal for download link
      const downloadLink = document.createElement("a");
      downloadLink.href = "#";
      downloadLink.className = "text-blue-600 hover:text-blue-800 underline";
      downloadLink.textContent = t("download");
      downloadLink.onclick = (e) => {
        e.preventDefault();
        s.canvas.toBlob(blob => {
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `${s.name}.png`;
          a.click();
          URL.revokeObjectURL(url);
        });
      };
      $previewDim.appendChild(downloadLink);
      updatePreviewCanvas();
    }

    /* ------------------- Select/Deselect All ------------------- */
    function toggleSelectAll(checked) {
      const checkboxes = $grid.querySelectorAll(".sprite-checkbox");
      checkboxes.forEach(cb => cb.checked = checked);
    }

    function updatePreviewCanvas() {
      if (!currentPreview) return;
      const ctx = $previewCanvas.getContext("2d");
      const s = currentPreview;
      const zoom = previewZoom;

      const targetW = Math.max(1, Math.floor(s.w * zoom));
      const targetH = Math.max(1, Math.floor(s.h * zoom));

      $previewCanvas.width = targetW;
      $previewCanvas.height = targetH;

      ctx.imageSmoothingEnabled = false;
      ctx.clearRect(0, 0, targetW, targetH);
      ctx.drawImage(s.canvas, 0, 0, targetW, targetH);

      if ($bboxToggle.checked) {
        ctx.strokeStyle = "red";
        ctx.lineWidth = 1.5;
        ctx.strokeRect(0.5, 0.5, targetW - 1, targetH - 1);
      }

      $zoomValue.textContent = zoom.toFixed(1) + "√ó";

      // Sync background style v·ªõi grid
      $previewBgWrap.className = `rounded-md p-2 ${getBgClass(bgMode)}`;
    }

    /* ------------------- ZIP ALL ------------------- */
    function zipAll(sprites) {
      // Get selected sprites from checkboxes
      const checkboxes = $grid.querySelectorAll(".sprite-checkbox:checked");
      const selectedNames = new Set(Array.from(checkboxes).map(cb => cb.dataset.spriteName).filter(Boolean));

      // Filter sprites by selected checkboxes
      const selectedSprites = sprites.filter(s => selectedNames.has(s.name));

      if (selectedSprites.length === 0) {
        alert("No sprites selected!");
        return;
      }

      const zip = new JSZip();
      const folder = zip.folder("images");

      Promise.all(
        selectedSprites.map(s => new Promise(res =>
          s.canvas.toBlob(blob => {
            folder.file(`${s.name}.png`, blob);
            res();
          })
        ))
      )
        .then(() => zip.generateAsync({ type: "blob" }))
        .then(blob => {
          const a = document.createElement("a");
          a.href = URL.createObjectURL(blob);
          a.download = "sprites.zip";
          a.click();
        });
    }

    /* ------------------- Export Grouped Metadata ------------------- */
    function exportMetadata(sprites) {
      const grouped = R.groupBy(s => s.atlas, sprites);

      const output = {};
      Object.keys(grouped).forEach(atlas => {
        output[atlas] = {
          file: atlas + ".atlas",
          sprites: grouped[atlas].map(s => ({
            name: s.name,
            width: s.w,
            height: s.h,
            x: s.xy.x,
            y: s.xy.y,
            regionWidth: s.size.w,
            regionHeight: s.size.h,
            rotate: s.rotate
          }))
        };
      });

      const blob = new Blob([JSON.stringify(output, null, 2)], { type: "application/json" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "metadata_grouped.json";
      a.click();
    }

    /* ------------------- MAIN ------------------- */
    $btnProcess.onclick = async () => {
      // Stop auto-process countdown if user clicks manually
      stopAutoProcessCountdown();

      if (!files.length) { alert(t("alertNoFiles")); return; }

      const bases = groupAtlasPngJson(files);
      if (!bases.length) {
        alert(t("alertMissingFiles"));
        return;
      }

      allSprites = [];

      for (const b of bases) {
        const spr = await parseAtlasWithPIXI(atlasList[b], pngList[b], b);
        allSprites.push(...spr);
      }

      // Exclude merged file sprites (sprites with name matching atlas base name)
      const baseNames = new Set(bases);
      allSprites = allSprites.filter(s => !baseNames.has(s.name));

      allSprites = sortSprites(allSprites, $sortSelect.value);
      renderGrid(allSprites);
    };

    /* SEARCH */
    $searchInput.oninput = e => {
      const q = e.target.value.toLowerCase();
      const filtered = allSprites.filter(s =>
        s.name.toLowerCase().includes(q) ||
        s.atlas.toLowerCase().includes(q)
      );
      renderGrid(filtered);
    };

    /* SORT */
    $sortSelect.onchange = () => {
      allSprites = sortSprites(allSprites, $sortSelect.value);
      renderGrid(allSprites);
    };

    /* BBOX */
    $bboxToggle.onchange = () => {
      renderGrid(allSprites);
      updatePreviewCanvas();
    };

    /* Background */
    $bgSelect.onchange = e => {
      bgMode = e.target.value;
      renderGrid(allSprites);
      updatePreviewCanvas();
    };

    /* Export metadata */
    $btnMeta.onclick = () => exportMetadata(allSprites);

    /* ZIP */
    $btnZip.onclick = () => zipAll(allSprites);

    /* Close preview panel */
    $btnClosePreview.onclick = () => closePreviewPanel();

    /* Select/Deselect All */
    $selectAllToggle.onchange = (e) => {
      toggleSelectAll(e.target.checked);
    };

    /* Update select all checkbox when individual checkboxes change */
    function updateSelectAllCheckbox() {
      const checkboxes = $grid.querySelectorAll(".sprite-checkbox");
      const checkedCount = $grid.querySelectorAll(".sprite-checkbox:checked").length;
      if (checkboxes.length > 0) {
        $selectAllToggle.checked = checkedCount === checkboxes.length;
        $selectAllToggle.indeterminate = checkedCount > 0 && checkedCount < checkboxes.length;
      }
    }

    /* Zoom slider for dynamic preview */
    $zoomSlider.oninput = e => {
      previewZoom = parseFloat(e.target.value) || 1;
      updatePreviewCanvas();
    };

    /* Fullscreen button in preview panel */
    $btnFullscreen.onclick = () => {
      if (currentPreview) {
        showModal(currentPreview.canvas);
      }
    };

    /* Clear button */
    $btnClear.onclick = () => {
      clearAll();
    };
  </script>

</body>

</html>
