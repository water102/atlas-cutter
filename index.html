<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="UTF-8" />
  <title>Atlas Cutter</title>

  <!-- TailwindCSS -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Ramda -->
  <script src="https://cdn.jsdelivr.net/npm/ramda@0.29.0/dist/ramda.min.js"></script>

  <!-- JSZip -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <!-- PIXI.js v7 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js"></script>


  <style>
    canvas {
      image-rendering: pixelated;
    }

    .modal-bg {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 50;
    }

    .bg-checker {
      background-image:
        linear-gradient(45deg, #d1d5db 25%, transparent 25%),
        linear-gradient(-45deg, #d1d5db 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, #d1d5db 75%),
        linear-gradient(-45deg, transparent 75%, #d1d5db 75%);
      background-size: 10px 10px;
      background-position: 0 0, 0 5px, 5px -5px, -5px 0;
    }

    /* Flex container */
    #grid {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    /* Grid item style */
    .grid-item {
      width: 180px;
    }

    .grid-item-content {
      width: 100%;
      background: white;
      border-radius: 6px;
      box-shadow: 0 0 6px rgba(0, 0, 0, 0.15);
      padding: 6px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }

    .sprite-preview-wrap {
      width: 100%;
      max-height: 200px;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .sprite-preview-wrap canvas {
      cursor: pointer;
      width: 100%;
      height: auto;
      max-height: 200px;
      image-rendering: pixelated;
      display: block;
      transform-origin: center center;
      transition: transform 0.12s ease-out;
    }

    .grid-item-content:hover .sprite-preview-wrap canvas {
      transform: scale(1.05);
    }

    /* Preview panel */
    #previewPanel {
      position: sticky;
      top: 96px;
      align-self: flex-start;
    }

    #previewCanvas {
      max-width: 100%;
      height: auto;
      image-rendering: pixelated;
      display: block;
    }
  </style>
</head>

<body class="bg-gray-100">

  <div class="max-w-6xl mx-auto py-8 px-4">
    <h1 class="text-3xl font-bold mb-4">üß© Atlas Cutter</h1>

    <!-- DropZone -->
    <div id="dropZone"
      class="border-2 border-dashed border-gray-400 bg-white rounded-lg p-6 text-center cursor-pointer transition">
      <div id="dropZoneContent">
        <p class="text-lg text-gray-700">üì¶ K√©o th·∫£ nhi·ªÅu file <b>.atlas + .png + .json</b> ho·∫∑c click ƒë·ªÉ ch·ªçn</p>
      </div>
      <div id="filePreview" class="mt-4 hidden">
        <div id="fileList" class="text-sm text-left space-y-2"></div>
        <div id="imagePreview" class="mt-4 flex flex-wrap gap-4 justify-center"></div>
      </div>
      <input id="fileInput" type="file" multiple accept=".atlas,.png,.json" class="hidden" />
    </div>

    <div class="mt-4 flex gap-3">
      <button id="btnProcess" class="px-4 py-2 bg-blue-600 text-white rounded shadow">
        C·∫Øt t·∫•t c·∫£ atlas
      </button>
      <button id="btnClear" class="px-4 py-2 bg-red-600 text-white rounded shadow">
        üóëÔ∏è Clear
      </button>
    </div>

    <!-- Controls -->
    <div class="mt-6 flex flex-wrap gap-3 items-center text-sm">
      <input id="searchInput" placeholder="üîç T√¨m sprite..." class="border rounded px-3 py-1 w-56" />

      <select id="sortSelect" class="border rounded px-2 py-1">
        <option value="nameAsc">T√™n A‚ÜíZ</option>
        <option value="nameDesc">T√™n Z‚ÜíA</option>
        <option value="wAsc">Width ‚Üë</option>
        <option value="wDesc">Width ‚Üì</option>
        <option value="hAsc">Height ‚Üë</option>
        <option value="hDesc">Height ‚Üì</option>
      </select>

      <label class="flex items-center gap-2">
        <input type="checkbox" id="bboxToggle"> Bounding box
      </label>

      <select id="bgSelect" class="border rounded px-2 py-1">
        <option value="checker">Checker</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
        <option value="transparent">Transparent</option>
      </select>

      <button id="btnMeta" class="px-3 py-1 bg-emerald-600 text-white rounded shadow">
        üìÑ Export Metadata JSON
      </button>

      <button id="btnZip" class="ml-auto px-3 py-1 bg-orange-600 text-white rounded shadow">
        üì¶ Download ZIP
      </button>
    </div>

    <!-- GRID + PREVIEW LAYOUT -->
    <div class="mt-6 flex flex-col lg:flex-row gap-6">
      <!-- FLEX GRID -->
      <div id="grid" class="flex-1"></div>

      <!-- Dynamic Zoom Preview Panel -->
      <div id="previewPanel" class="w-full lg:w-80 bg-white rounded-lg shadow-md p-4 hidden">
        <h2 class="text-sm font-semibold mb-2 flex items-center gap-1">
          üîç Dynamic Preview
        </h2>
        <div id="previewTitle" class="text-xs font-semibold mb-1 truncate text-gray-800"></div>
        <div id="previewDim" class="text-[11px] text-gray-500 mb-2"></div>

        <div id="previewBgWrap" class="bg-checker rounded-md p-2 mb-3">
          <canvas id="previewCanvas"></canvas>
        </div>

        <div class="flex items-center gap-2 text-xs">
          <span class="whitespace-nowrap">Zoom</span>
          <input id="zoomSlider" type="range" min="0.5" max="8" step="0.5" value="2" class="flex-1">
          <span id="zoomValue" class="w-10 text-right text-[11px] text-gray-500">2√ó</span>
        </div>

        <button id="btnFullscreen"
          class="mt-3 w-full px-3 py-1 text-xs bg-gray-800 text-white rounded hover:bg-gray-900">
          ‚õ∂ Xem fullscreen
        </button>

        <p class="mt-2 text-[11px] text-gray-500">
          üí° Tip: Click v√†o sprite trong grid ƒë·ªÉ xem ·ªü ƒë√¢y. Double-click ƒë·ªÉ m·ªü fullscreen.
        </p>
      </div>
    </div>
  </div>

  <!-- Modal -->
  <div id="modal" class="hidden"></div>

  <script>
    const $ = id => document.getElementById(id);

    // Element references
    const $dropZone = $("dropZone");
    const $dropZoneContent = $("dropZoneContent");
    const $filePreview = $("filePreview");
    const $fileList = $("fileList");
    const $imagePreview = $("imagePreview");
    const $fileInput = $("fileInput");
    const $grid = $("grid");
    const $bboxToggle = $("bboxToggle");
    const $previewPanel = $("previewPanel");
    const $previewTitle = $("previewTitle");
    const $previewDim = $("previewDim");
    const $previewCanvas = $("previewCanvas");
    const $previewBgWrap = $("previewBgWrap");
    const $zoomValue = $("zoomValue");
    const $modal = $("modal");
    const $btnProcess = $("btnProcess");
    const $btnClear = $("btnClear");
    const $sortSelect = $("sortSelect");
    const $searchInput = $("searchInput");
    const $bgSelect = $("bgSelect");
    const $btnMeta = $("btnMeta");
    const $btnZip = $("btnZip");
    const $zoomSlider = $("zoomSlider");
    const $btnFullscreen = $("btnFullscreen");

    let files = [];
    let atlasList = {};
    let pngList = {};
    let jsonList = {};
    let allSprites = [];
    let bgMode = "checker";

    // Dynamic preview state
    let currentPreview = null;
    let previewZoom = 2;

    // Auto-process countdown
    let autoProcessTimeout = null;
    let countdownInterval = null;
    let countdownSeconds = 3;

    /* ------------------- Helper: BG Class ------------------- */
    function getBgClass(mode) {
      return ({
        checker: "bg-checker",
        light: "bg-gray-200",
        dark: "bg-slate-900",
        transparent: "bg-transparent"
      }[mode] || "bg-checker");
    }

    /* ------------------- CLEAR ALL ------------------- */
    function clearAll() {
      // Stop countdown
      stopAutoProcessCountdown();

      // Clear files
      files = [];
      atlasList = {};
      pngList = {};
      jsonList = {};
      allSprites = [];
      currentPreview = null;

      // Reset file input
      $fileInput.value = "";

      // Reset UI
      $filePreview.classList.add("hidden");
      $dropZoneContent.innerHTML = '<p class="text-lg text-gray-700">üì¶ K√©o th·∫£ nhi·ªÅu file <b>.atlas + .png + .json</b> ho·∫∑c click ƒë·ªÉ ch·ªçn</p>';
      $grid.innerHTML = "";
      $previewPanel.classList.add("hidden");
      $searchInput.value = "";
      $sortSelect.value = "nameAsc";
      $bboxToggle.checked = false;
      $bgSelect.value = "checker";
      bgMode = "checker";
      previewZoom = 2;
      $zoomSlider.value = "2";
    }

    /* ------------------- AUTO-PROCESS COUNTDOWN ------------------- */
    function stopAutoProcessCountdown() {
      if (autoProcessTimeout) {
        clearTimeout(autoProcessTimeout);
        autoProcessTimeout = null;
      }
      if (countdownInterval) {
        clearInterval(countdownInterval);
        countdownInterval = null;
      }
      $btnProcess.textContent = "C·∫Øt t·∫•t c·∫£ atlas";
      $btnProcess.classList.remove("animate-pulse");
    }

    function updateCountdownButton() {
      if (countdownSeconds > 0) {
        $btnProcess.textContent = `C·∫Øt t·∫•t c·∫£ atlas (${countdownSeconds}s)`;
        $btnProcess.classList.add("animate-pulse");
      } else {
        $btnProcess.textContent = "C·∫Øt t·∫•t c·∫£ atlas";
        $btnProcess.classList.remove("animate-pulse");
      }
    }

    function startAutoProcessCountdown() {
      // Stop existing countdown if any
      stopAutoProcessCountdown();
      
      // Reset countdown
      countdownSeconds = 3;
      updateCountdownButton();
      
      // Update button every second
      countdownInterval = setInterval(() => {
        countdownSeconds--;
        updateCountdownButton();
        
        if (countdownSeconds <= 0) {
          stopAutoProcessCountdown();
          // Auto trigger process
          $btnProcess.click();
        }
      }, 1000);
    }

    /* ------------------- DRAG & DROP ------------------- */
    function updateFilePreview() {
      if (files.length === 0) {
        $filePreview.classList.add("hidden");
        $dropZoneContent.innerHTML = '<p class="text-lg text-gray-700">üì¶ K√©o th·∫£ nhi·ªÅu file <b>.atlas + .png + .json</b> ho·∫∑c click ƒë·ªÉ ch·ªçn</p>';
        stopAutoProcessCountdown();
        return;
      }
      
      $filePreview.classList.remove("hidden");
      $dropZoneContent.innerHTML = `<p class="text-lg text-gray-700 font-semibold text-green-600">‚úÖ ƒê√£ ch·ªçn ${files.length} file</p>`;
      
      // Group files
      const atlasFiles = files.filter(f => /\.atlas$/i.test(f.name));
      const pngFiles = files.filter(f => /\.png$/i.test(f.name));
      const jsonFiles = files.filter(f => /\.json$/i.test(f.name));
      
      $fileList.innerHTML = `
        <div class="grid grid-cols-3 gap-2 text-xs">
          <div class="bg-blue-50 p-2 rounded">
            <div class="font-semibold">Atlas (.atlas)</div>
            <div class="text-gray-600">${atlasFiles.length} file</div>
          </div>
          <div class="bg-green-50 p-2 rounded">
            <div class="font-semibold">Image (.png)</div>
            <div class="text-gray-600">${pngFiles.length} file</div>
          </div>
          <div class="bg-purple-50 p-2 rounded">
            <div class="font-semibold">JSON (.json)</div>
            <div class="text-gray-600">${jsonFiles.length} file</div>
          </div>
        </div>
        <div class="mt-2 text-xs text-gray-600 max-h-32 overflow-y-auto">
          ${files.map(f => `<div class="truncate">‚Ä¢ ${f.name}</div>`).join('')}
        </div>
      `;
      
      // Preview PNG images
      $imagePreview.innerHTML = "";
      pngFiles.forEach(file => {
        const reader = new FileReader();
        reader.onload = (e) => {
          const img = document.createElement("img");
          img.src = e.target.result;
          img.className = "max-w-32 max-h-32 object-contain border rounded shadow";
          img.title = file.name;
          $imagePreview.appendChild(img);
        };
        reader.readAsDataURL(file);
      });

      // Start auto-process countdown (reset if user adds more files)
      startAutoProcessCountdown();
    }
    
    $dropZone.onclick = () => $fileInput.click();
    ["dragenter", "dragover"].forEach(ev =>
      $dropZone.addEventListener(ev, e => {
        e.preventDefault();
        $dropZone.classList.add("border-blue-500", "bg-blue-50");
      })
    );
    ["dragleave", "drop"].forEach(ev =>
      $dropZone.addEventListener(ev, e => {
        e.preventDefault();
        $dropZone.classList.remove("border-blue-500", "bg-blue-50");
      })
    );
    $dropZone.addEventListener("drop", e => {
      files = [...e.dataTransfer.files];
      updateFilePreview();
    });
    $fileInput.onchange = e => {
      files = [...e.target.files];
      updateFilePreview();
    };

    /* ------------------- GROUP FILES ------------------- */
    const groupAtlasPngJson = (files) => {
      atlasList = {};
      pngList = {};
      jsonList = {};
      files.forEach(f => {
        const base = f.name.replace(/\.(atlas|png|json)$/i, "");
        if (/\.atlas$/i.test(f.name)) atlasList[base] = f;
        if (/\.png$/i.test(f.name)) pngList[base] = f;
        if (/\.json$/i.test(f.name)) jsonList[base] = f;
      });
      // Require all 3 file types for each base name
      return Object.keys(atlasList).filter(k => pngList[k] && jsonList[k]);
    };

    /* ------------------- PIXI PARSE ATLAS ------------------- */
    async function parseAtlasWithPIXI(atlasFile, pngFile, atlasName) {
      // ƒë·ªçc n·ªôi dung .atlas (metadata)
      const atlasText = await atlasFile.text();

      // parse metadata th·ªß c√¥ng (xy, size, rotate)
      const regions = manualParseAtlas(atlasText, atlasName);

      // t·∫°o base texture t·ª´ blob PNG
      const pngURL = URL.createObjectURL(pngFile);
      const baseTexture = new PIXI.BaseTexture(pngURL);

      // duy·ªát t·ª´ng region v√† t·∫°o sprite canvas
      return await Promise.all(
        regions.map(async region => {
          const { name, xy, size, rotate } = region;

          // t·∫°o sub-frame gi·ªëng texture atlas th·ª±c t·∫ø
          const frame = new PIXI.Rectangle(xy.x, xy.y, size.w, size.h);

          // t·∫°o texture con (kh√¥ng d√πng tr·ª±c ti·∫øp, ch·ªâ ƒë·ªÉ tham chi·∫øu logic)
          const subTex = new PIXI.Texture(baseTexture, frame);

          // xu·∫•t canvas
          const c = document.createElement("canvas");
          c.width = rotate ? size.h : size.w;
          c.height = rotate ? size.w : size.h;
          const ctx = c.getContext("2d");

          const img = new Image();
          img.src = pngURL;

          await new Promise(res => img.onload = res);

          if (rotate) {
            // rotate 90 degrees clockwise
            ctx.save();
            ctx.translate(c.width / 2, c.height / 2);
            ctx.rotate(Math.PI / 2);
            ctx.drawImage(
              img,
              xy.x, xy.y, size.w, size.h,
              -size.w / 2, -size.h / 2,
              size.w, size.h
            );
            ctx.restore();
          } else {
            ctx.drawImage(
              img,
              xy.x, xy.y, size.w, size.h,
              0, 0,
              size.w, size.h
            );
          }

          return {
            name,
            atlas: atlasName,
            canvas: c,
            w: c.width,
            h: c.height,
            xy,
            size,
            rotate
          };
        })
      );
    }

    /* ------------------- MANUAL METADATA PARSER ------------------- */
    function manualParseAtlas(text, atlasName) {
      const lines = text.split(/\r?\n/);
      let regions = [];
      let cur = null;

      const isStart = raw =>
        raw.trim() && !raw.startsWith(" ") && !raw.includes(":");

      lines.forEach(raw => {
        const line = raw.trim();

        if (isStart(raw)) {
          cur && regions.push(cur);
          cur = {
            atlas: atlasName,
            name: line,
            rotate: false,
            xy: { x: 0, y: 0 },
            size: { w: 0, h: 0 }
          };
          return;
        }

        if (!cur) return;

        if (line.startsWith("rotate")) cur.rotate = line.includes("true");
        if (line.startsWith("xy:")) {
          const m = line.match(/xy:\s*(\d+),\s*(\d+)/);
          if (m) cur.xy = { x: +m[1], y: +m[2] };
        }
        if (line.startsWith("size:")) {
          const m = line.match(/size:\s*(\d+),\s*(\d+)/);
          if (m) cur.size = { w: +m[1], h: +m[2] };
        }
      });

      cur && regions.push(cur);
      return regions;
    }

    /* ------------------- RENDER FLEX GRID ------------------- */
    function renderGrid(sprites) {
      $grid.innerHTML = "";

      const bgClass = getBgClass(bgMode);

      sprites.forEach(s => {
        // Grid item
        const item = document.createElement("div");
        item.className = "grid-item";
        const content = document.createElement("div");
        content.className = "grid-item-content";

        // Label
        const label = document.createElement("div");
        label.className = "text-xs font-semibold text-center truncate w-full";
        label.textContent = s.name;

        // Preview container
        const prevWrap = document.createElement("div");
        prevWrap.className = `sprite-preview-wrap p-2 ${bgClass}`;

        // Canvas preview
        const preview = document.createElement("canvas");
        preview.width = s.w;
        preview.height = s.h;
        const ctx = preview.getContext("2d");
        ctx.drawImage(s.canvas, 0, 0);

        if ($bboxToggle.checked) {
          ctx.strokeStyle = "red";
          ctx.lineWidth = 1.2;
          ctx.strokeRect(0, 0, s.w, s.h);
        }

        // Wheel zoom (local sprite zoom)
        let zoom = 1;
        preview.onwheel = e => {
          e.preventDefault();
          zoom += (e.deltaY < 0 ? 0.2 : -0.2);
          zoom = Math.min(8, Math.max(0.5, zoom));
          preview.style.transform = `scale(${zoom})`;
        };

        // Click = update dynamic preview panel
        preview.onclick = () => setPreviewSprite(s);

        // Double-click = fullscreen modal
        preview.ondblclick = () => showModal(s.canvas);

        prevWrap.appendChild(preview);

        const dim = document.createElement("div");
        dim.className = "text-[11px] text-gray-500 flex items-center gap-1 justify-center";
        dim.innerHTML = `${s.w}√ó${s.h} ‚Ä¢ `;
        
        const downloadLink = document.createElement("a");
        downloadLink.href = "#";
        downloadLink.className = "text-blue-600 hover:text-blue-800 underline";
        downloadLink.textContent = "Download";
        downloadLink.onclick = (e) => {
          e.preventDefault();
          s.canvas.toBlob(blob => {
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `${s.name}.png`;
            a.click();
            URL.revokeObjectURL(url);
          });
        };
        dim.appendChild(downloadLink);

        content.append(label, prevWrap, dim);
        item.appendChild(content);
        $grid.appendChild(item);
      });

      // Repaint preview if sprite ƒëang ƒë∆∞·ª£c ch·ªçn
      updatePreviewCanvas();
    }

    /* ------------------- Sorting ------------------- */
    function sortSprites(arr, type) {
      switch (type) {
        case "nameAsc": return R.sortBy(s => s.name.toLowerCase(), arr);
        case "nameDesc": return R.sort(R.descend(s => s.name.toLowerCase()), arr);
        case "wAsc": return R.sortBy(s => s.w, arr);
        case "wDesc": return R.sort(R.descend(s => s.w), arr);
        case "hAsc": return R.sortBy(s => s.h, arr);
        case "hDesc": return R.sort(R.descend(s => s.h), arr);
      }
      return arr;
    }

    /* ------------------- Modal ------------------- */
    function showModal(canvas) {
      $modal.innerHTML = `
      <div class="modal-bg" onclick="closeModal()">
        <img src="${canvas.toDataURL()}" class="max-w-[90vw] max-h-[90vh] bg-white shadow-lg border" />
      </div>`;
      $modal.classList.remove("hidden");
    }
    function closeModal() {
      $modal.classList.add("hidden");
    }

    /* ------------------- Dynamic Preview Panel ------------------- */
    function setPreviewSprite(s) {
      currentPreview = s;
      if ($previewPanel.classList.contains("hidden")) {
        $previewPanel.classList.remove("hidden");
      }
      $previewTitle.textContent = s.name;
      $previewDim.innerHTML = `${s.w}√ó${s.h} ‚Ä¢ `;
      const downloadLink = document.createElement("a");
      downloadLink.href = "#";
      downloadLink.className = "text-blue-600 hover:text-blue-800 underline";
      downloadLink.textContent = "Download";
      downloadLink.onclick = (e) => {
        e.preventDefault();
        s.canvas.toBlob(blob => {
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `${s.name}.png`;
          a.click();
          URL.revokeObjectURL(url);
        });
      };
      $previewDim.appendChild(downloadLink);
      updatePreviewCanvas();
    }

    function updatePreviewCanvas() {
      if (!currentPreview) return;
      const ctx = $previewCanvas.getContext("2d");
      const s = currentPreview;
      const zoom = previewZoom;

      const targetW = Math.max(1, Math.floor(s.w * zoom));
      const targetH = Math.max(1, Math.floor(s.h * zoom));

      $previewCanvas.width = targetW;
      $previewCanvas.height = targetH;

      ctx.imageSmoothingEnabled = false;
      ctx.clearRect(0, 0, targetW, targetH);
      ctx.drawImage(s.canvas, 0, 0, targetW, targetH);

      if ($bboxToggle.checked) {
        ctx.strokeStyle = "red";
        ctx.lineWidth = 1.5;
        ctx.strokeRect(0.5, 0.5, targetW - 1, targetH - 1);
      }

      $zoomValue.textContent = zoom.toFixed(1) + "√ó";

      // Sync background style v·ªõi grid
      $previewBgWrap.className = `rounded-md p-2 ${getBgClass(bgMode)}`;
    }

    /* ------------------- ZIP ALL ------------------- */
    function zipAll(sprites) {
      const zip = new JSZip();
      const folder = zip.folder("images");

      Promise.all(
        sprites.map(s => new Promise(res =>
          s.canvas.toBlob(blob => {
            folder.file(`${s.name}.png`, blob);
            res();
          })
        ))
      )
        .then(() => zip.generateAsync({ type: "blob" }))
        .then(blob => {
          const a = document.createElement("a");
          a.href = URL.createObjectURL(blob);
          a.download = "sprites.zip";
          a.click();
        });
    }

    /* ------------------- Export Grouped Metadata ------------------- */
    function exportMetadata(sprites) {
      const grouped = R.groupBy(s => s.atlas, sprites);

      const output = {};
      Object.keys(grouped).forEach(atlas => {
        output[atlas] = {
          file: atlas + ".atlas",
          sprites: grouped[atlas].map(s => ({
            name: s.name,
            width: s.w,
            height: s.h,
            x: s.xy.x,
            y: s.xy.y,
            regionWidth: s.size.w,
            regionHeight: s.size.h,
            rotate: s.rotate
          }))
        };
      });

      const blob = new Blob([JSON.stringify(output, null, 2)], { type: "application/json" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "metadata_grouped.json";
      a.click();
    }

    /* ------------------- MAIN ------------------- */
    $btnProcess.onclick = async () => {
      // Stop auto-process countdown if user clicks manually
      stopAutoProcessCountdown();

      if (!files.length) { alert("Ch∆∞a c√≥ file!"); return; }

      const bases = groupAtlasPngJson(files);
      if (!bases.length) {
        alert("Kh√¥ng t√¨m th·∫•y ƒë·ªß 3 lo·∫°i file (atlas + png + json) cho c√πng m·ªôt t√™n base!");
        return;
      }

      allSprites = [];

      for (const b of bases) {
        const spr = await parseAtlasWithPIXI(atlasList[b], pngList[b], b);
        allSprites.push(...spr);
      }

      // Exclude merged file sprites (sprites with name matching atlas base name)
      const baseNames = new Set(bases);
      allSprites = allSprites.filter(s => !baseNames.has(s.name));

      allSprites = sortSprites(allSprites, $sortSelect.value);
      renderGrid(allSprites);
    };

    /* SEARCH */
    $searchInput.oninput = e => {
      const q = e.target.value.toLowerCase();
      const filtered = allSprites.filter(s =>
        s.name.toLowerCase().includes(q) ||
        s.atlas.toLowerCase().includes(q)
      );
      renderGrid(filtered);
    };

    /* SORT */
    $sortSelect.onchange = () => {
      allSprites = sortSprites(allSprites, $sortSelect.value);
      renderGrid(allSprites);
    };

    /* BBOX */
    $bboxToggle.onchange = () => {
      renderGrid(allSprites);
      updatePreviewCanvas();
    };

    /* Background */
    $bgSelect.onchange = e => {
      bgMode = e.target.value;
      renderGrid(allSprites);
      updatePreviewCanvas();
    };

    /* Export metadata */
    $btnMeta.onclick = () => exportMetadata(allSprites);

    /* ZIP */
    $btnZip.onclick = () => zipAll(allSprites);

    /* Zoom slider for dynamic preview */
    $zoomSlider.oninput = e => {
      previewZoom = parseFloat(e.target.value) || 1;
      updatePreviewCanvas();
    };

    /* Fullscreen button in preview panel */
    $btnFullscreen.onclick = () => {
      if (currentPreview) {
        showModal(currentPreview.canvas);
      }
    };

    /* Clear button */
    $btnClear.onclick = () => {
      clearAll();
    };
  </script>

</body>

</html>
